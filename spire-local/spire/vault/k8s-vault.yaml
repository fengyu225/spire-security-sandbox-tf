apiVersion: v1
kind: ServiceAccount
metadata:
  name: vault-init
  namespace: spire
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: vault-init-role
  namespace: spire
rules:
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["create", "get", "patch", "delete", "update"]
  - apiGroups: [""]
    resources: ["pods/exec"]
    verbs: ["create"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: vault-init-binding
  namespace: spire
subjects:
  - kind: ServiceAccount
    name: vault-init
    namespace: spire
roleRef:
  kind: Role
  name: vault-init-role
  apiGroup: rbac.authorization.k8s.io
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: vault-config
  namespace: spire
data:
  vault.hcl: |
    ui = true
    disable_mlock = true
    api_addr = "https://vault:8200"

    storage "file" {
      path = "/vault/data"
    }

    listener "tcp" {
      address       = "0.0.0.0:8200"
      tls_disable   = false
      tls_cert_file = "/vault/tls/tls.crt"
      tls_key_file  = "/vault/tls/tls.key"
    }
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: vault
  namespace: spire
  labels:
    app: vault
spec:
  serviceName: vault
  replicas: 1
  selector:
    matchLabels:
      app: vault
  template:
    metadata:
      labels:
        app: vault
    spec:
      containers:
        - name: vault
          image: hashicorp/vault:1.15
          command: ["vault"]
          args: ["server", "-config=/vault/config/vault.hcl"]
          env:
            - name: SKIP_CHOWN
              value: "true"
            - name: SKIP_SETCAP
              value: "true"
            - name: VAULT_ADDR
              value: "https://127.0.0.1:8200"
            - name: VAULT_SKIP_VERIFY
              value: "true"
          securityContext:
            capabilities:
              add: ["IPC_LOCK"]
          ports:
            - containerPort: 8200
          volumeMounts:
            - name: vault-data
              mountPath: /vault/data
            - name: vault-config
              mountPath: /vault/config
            - name: vault-tls
              mountPath: /vault/tls
              readOnly: true
          readinessProbe:
            exec:
              command:
                - /bin/sh
                - -c
                - "VAULT_ADDR='https://127.0.0.1:8200' VAULT_SKIP_VERIFY=true vault status"
            initialDelaySeconds: 5
            periodSeconds: 5
            failureThreshold: 30
      volumes:
        - name: vault-config
          configMap:
            name: vault-config
        - name: vault-tls
          secret:
            secretName: vault-tls
            optional: true  # Allow pod to start before secret exists
  volumeClaimTemplates:
    - metadata:
        name: vault-data
      spec:
        accessModes: [ "ReadWriteOnce" ]
        resources:
          requests:
            storage: 1Gi
---
apiVersion: v1
kind: Service
metadata:
  name: vault
  namespace: spire
spec:
  publishNotReadyAddresses: true
  ports:
    - port: 8200
      targetPort: 8200
  selector:
    app: vault
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: vault-init-script
  namespace: spire
data:
  init.sh: |
    #!/bin/sh
    set -e

    apk add --no-cache openssl curl jq

    curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
    chmod +x kubectl
    mv kubectl /usr/local/bin/

    echo "Checking for existing Vault TLS certificates..."
    if ! kubectl get secret vault-tls -n spire >/dev/null 2>&1; then
      echo "Generating Vault TLS certificates..."
      mkdir -p /tmp/vault-tls

      # Generate CA
      openssl genrsa -out /tmp/vault-tls/ca.key 4096
      openssl req -new -x509 -days 3650 -key /tmp/vault-tls/ca.key \
        -out /tmp/vault-tls/ca.crt \
        -subj "/CN=Vault CA/O=SPIRE"

      # Generate Vault server certificate
      openssl genrsa -out /tmp/vault-tls/tls.key 4096
      openssl req -new -key /tmp/vault-tls/tls.key \
        -out /tmp/vault-tls/tls.csr \
        -subj "/CN=vault/O=SPIRE" \
        -addext "subjectAltName=DNS:vault,DNS:vault.spire,DNS:vault.spire.svc,DNS:vault.spire.svc.cluster.local,DNS:localhost,IP:127.0.0.1"

      openssl x509 -req -in /tmp/vault-tls/tls.csr \
        -CA /tmp/vault-tls/ca.crt -CAkey /tmp/vault-tls/ca.key -CAcreateserial \
        -out /tmp/vault-tls/tls.crt -days 3650 -sha256 \
        -extfile <(printf "subjectAltName=DNS:vault,DNS:vault.spire,DNS:vault.spire.svc,DNS:vault.spire.svc.cluster.local,DNS:localhost,IP:127.0.0.1")

      # Create Kubernetes secret
      kubectl create secret generic vault-tls \
        --from-file=ca.crt=/tmp/vault-tls/ca.crt \
        --from-file=tls.crt=/tmp/vault-tls/tls.crt \
        --from-file=tls.key=/tmp/vault-tls/tls.key \
        -n spire

      echo "Vault TLS certificates created and stored in vault-tls secret"

      # Wait for Vault to restart with TLS enabled
      echo "Waiting for Vault pod to restart with TLS..."
      sleep 30
    else
      echo "Vault TLS certificates already exist"
    fi

    export VAULT_ADDR='https://vault:8200'
    export VAULT_CACERT='/tmp/vault-tls/ca.crt'

    # Extract CA from secret for local use
    kubectl get secret vault-tls -n spire -o jsonpath='{.data.ca\.crt}' | base64 -d > /tmp/vault-tls/ca.crt

    echo "Waiting for Vault..."
    until curl -k -s $VAULT_ADDR/v1/sys/health > /dev/null 2>&1; do
      sleep 2
    done

    echo "Vault is reachable. Checking status..."

    INIT_STATUS=$(curl -k -s $VAULT_ADDR/v1/sys/init | jq -r .initialized)

    if [ "$INIT_STATUS" = "false" ]; then
      echo "Initializing Vault..."

      INIT_JSON=$(vault operator init -key-shares=1 -key-threshold=1 -format=json)
      UNSEAL_KEY=$(echo $INIT_JSON | jq -r ".unseal_keys_b64[0]")
      ROOT_TOKEN=$(echo $INIT_JSON | jq -r ".root_token")

      kubectl create secret generic vault-recovery-keys \
        --from-literal=unseal_key=$UNSEAL_KEY \
        --from-literal=root_token=$ROOT_TOKEN \
        -n spire --dry-run=client -o yaml | kubectl apply -f -

      echo "Vault Initialized. Keys saved to 'vault-recovery-keys' secret."
    else
      echo "Vault already initialized. Fetching keys from secret..."
      UNSEAL_KEY=$(kubectl get secret vault-recovery-keys -n spire -o jsonpath='{.data.unseal_key}' | base64 -d)
      ROOT_TOKEN=$(kubectl get secret vault-recovery-keys -n spire -o jsonpath='{.data.root_token}' | base64 -d)
    fi

    echo "Unsealing Vault..."
    vault operator unseal $UNSEAL_KEY

    export VAULT_TOKEN=$ROOT_TOKEN

    echo "Configuring PKI (Idempotent)..."

    if ! vault secrets list | grep -q "pki_root/"; then
        vault secrets enable -path=pki_root pki
        vault secrets tune -max-lease-ttl=87600h pki_root

        vault write pki_root/root/generate/internal \
            common_name="SPIRE Root CA" \
            ttl=87600h \
            key_type="ec" \
            key_bits=384 \
            issuer_name="spire-root-2025"

        vault write pki_root/config/urls \
            issuing_certificates="$VAULT_ADDR/v1/pki_root/ca" \
            crl_distribution_points="$VAULT_ADDR/v1/pki_root/crl"
    fi

    if ! vault auth list | grep -q "cert/"; then
        vault auth enable cert
        vault auth tune -max-lease-ttl=87600h cert
    fi

    echo "Generating/Refreshing Client Certs..."
    mkdir -p certs

    openssl genrsa -out certs/client.key 4096
    openssl req -new -key certs/client.key -out certs/client.csr \
        -subj "/CN=spire-server/O=SPIRE"

    openssl x509 -req -in certs/client.csr \
        -signkey certs/client.key \
        -out certs/client.crt \
        -days 3650 -sha256

    vault policy write spire-server-policy - <<EOF
    path "pki_root/root/sign-intermediate" { capabilities = ["create", "update"] }
    path "pki_root/cert/ca" { capabilities = ["read"] }
    path "pki_root/crl" { capabilities = ["read"] }
    path "auth/cert/login" { capabilities = ["create", "read"] }
    path "pki_root/config/*" { capabilities = ["read"] }
    path "pki_root/roles/*" { capabilities = ["create", "read", "update"] }
    path "pki_root/issue/*" { capabilities = ["create", "update"] }
    EOF

    vault write auth/cert/certs/spire-server \
        display_name="spire-server" \
        policies="spire-server-policy" \
        certificate=@certs/client.crt \
        ttl=87600h \
        allowed_common_names="spire-server" \
        allowed_organizations="SPIRE" \
        require_matching_certificates=true

    vault read -field=certificate pki_root/cert/ca > certs/ca.crt

    # Get Vault's TLS CA for SPIRE
    kubectl get secret vault-tls -n spire -o jsonpath='{.data.ca\.crt}' | base64 -d > certs/vault-ca.crt

    echo "Updating Kubernetes Secret..."
    kubectl create secret generic vault-certs \
      --from-file=ca.crt=certs/ca.crt \
      --from-file=vault-ca.crt=certs/vault-ca.crt \
      --from-file=client.crt=certs/client.crt \
      --from-file=client.key=certs/client.key \
      -n spire --dry-run=client -o yaml | kubectl apply -f -

    echo "Vault Initialization Complete!"
---
apiVersion: batch/v1
kind: Job
metadata:
  name: vault-init-job
  namespace: spire
spec:
  ttlSecondsAfterFinished: 600
  template:
    spec:
      serviceAccountName: vault-init
      restartPolicy: OnFailure
      containers:
        - name: init
          image: hashicorp/vault:1.15
          command: ["/bin/sh", "/scripts/init.sh"]
          volumeMounts:
            - name: script-vol
              mountPath: /scripts
      volumes:
        - name: script-vol
          configMap:
            name: vault-init-script
            defaultMode: 0755